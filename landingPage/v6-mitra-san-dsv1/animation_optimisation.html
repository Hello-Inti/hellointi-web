<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hello Inti | Transform Your Network Into a Living Ecosystem</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/AttrPlugin.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        @media (prefers-reduced-motion: reduce) {
            .network-node, .connection-line {
                animation: none !important;
                transition: none !important;
            }
        }
        .network-node {
            will-change: transform;
        }
        .connection-line {
            will-change: stroke-opacity;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body class="font-body text-charcoal bg-eggshell">
    <!-- Hero Section -->
    <section id="hero-section" class="hero-section pt-20 pb-24 md:pt-32 md:pb-32 overflow-hidden min-h-screen">
        <div class="container mx-auto px-4">
            <div class="max-w-6xl mx-auto">
                <div class="grid lg:grid-cols-2 gap-12 items-center">
                    <div class="space-y-8">
                        <div class="space-y-6">
                            <h1 class="text-4xl md:text-5xl lg:text-6xl font-display font-semibold leading-tight">
                                Transform Your Network Into a
                                <span class="text-avocado relative" id="livingEcosystem">
                                    Living Ecosystem
                                    <div class="absolute -bottom-2 left-0 w-full h-1 bg-sunbeam/30 rounded transform rotate-1"></div>
                                </span>
                            </h1>
                            <p class="text-xl md:text-2xl text-charcoal/80 leading-relaxed ml-4">
                                Stop watching your community <span class="drift-left">drift</span> ... <span class="drift-right">apart</span>. <span class="text-avocado relative">Activate</span> dormant connections and ✨spark✨ chain reactions of collaboration through our proven peer-to-peer activation system.
                            </p>
                        </div>
                    </div>

                    <div class="relative">
                        <div class="hero-visual">
                            <div class="network-animation">
                                <!-- SVG for connection lines -->
                                <svg class="connections-svg" id="connectionsSvg">
                                    <!-- Connection lines will be dynamically generated -->
                                </svg>

                                <!-- Network nodes - 12 people with random colors and positions -->
                                <div class="network-node color-poppy" id="node1"></div>
                                <div class="network-node color-sunbeam" id="node2"></div>
                                <div class="network-node color-peach" id="node3"></div>
                                <div class="network-node color-avocado" id="node4"></div>
                                <div class="network-node color-lavender" id="node5"></div>
                                <div class="network-node color-poppy" id="node6"></div>
                                <div class="network-node color-sunbeam" id="node7"></div>
                                <div class="network-node color-peach" id="node8"></div>
                                <div class="network-node color-avocado" id="node9"></div>
                                <div class="network-node color-lavender" id="node10"></div>
                                <div class="network-node color-poppy" id="node11"></div>
                                <div class="network-node color-sunbeam" id="node12"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <script>
        'use strict';

        // Reduced motion check
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReducedMotion) {
            document.documentElement.classList.add('reduced-motion');
            // Pause GSAP globally if needed
            gsap.globalTimeline.pause();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initOptimizedNetworkAnimation();
        });

        function initOptimizedNetworkAnimation() {
            const container = document.querySelector('.network-animation');
            if (!container) return;

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const animation = new OptimizedNetworkAnimation();
                        animation.start();
                        observer.unobserve(container); // Run only once
                    }
                });
            }, { threshold: 0.5 });

            observer.observe(container);
        }

        class OptimizedNetworkAnimation {
            constructor() {
                this.container = document.querySelector('.network-animation');
                this.nodes = Array.from(this.container.querySelectorAll('.network-node'));
                this.connectionsSvg = document.getElementById('connectionsSvg');
                this.connections = [];
                this.nodePositions = [];
                this.circleTargets = [];
                this.isTransformed = false;
                this.masterTimeline = gsap.timeline({ paused: true });
            }

            init() {
                if (this.nodes.length === 0 || !this.connectionsSvg) return;

                this.setupNodes();
                this.generateConnections();
                this.buildMasterTimeline();
                this.updateAllConnections(); // Set initial line positions
            }

            setupNodes() {
                const containerRect = this.container.getBoundingClientRect();
                const nodeSize = 29;
                const margin = nodeSize + 10;
                const positions = [];
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                const radius = Math.min(containerRect.width, containerRect.height) * 0.35;
                this.circleTargets = [];

                this.nodes.forEach((node, index) => {
                    let x, y, attempts = 0;
                    let validPosition = false;

                    while (!validPosition && attempts < 50) {
                        x = margin + Math.random() * (containerRect.width - 2 * margin);
                        y = margin + Math.random() * (containerRect.height - 2 * margin);
                        validPosition = positions.every(pos => Math.hypot(x - pos.x, y - pos.y) >= nodeSize * 2);
                        attempts++;
                    }

                    if (!validPosition) {
                        const cols = 4;
                        const row = Math.floor(index / cols);
                        const col = index % cols;
                        x = (containerRect.width / cols) * (col + 0.5);
                        y = (containerRect.height / 3) * (row + 0.5);
                    }

                    positions.push({ x, y });
                    // Use transforms for positioning
                    gsap.set(node, { x: x - nodeSize / 2, y: y - nodeSize / 2 });

                    // Precompute circle target
                    const angle = (index / this.nodes.length) * Math.PI * 2;
                    this.circleTargets.push({
                        x: centerX + Math.cos(angle) * radius - nodeSize / 2,
                        y: centerY + Math.sin(angle) * radius - nodeSize / 2
                    });
                });

                this.nodePositions = positions;

                // Set SVG dimensions
                this.connectionsSvg.setAttribute('width', containerRect.width);
                this.connectionsSvg.setAttribute('height', containerRect.height);
                this.connectionsSvg.setAttribute('viewBox', `0 0 ${containerRect.width} ${containerRect.height}`);
            }

            generateConnections() {
                this.connectionsSvg.innerHTML = '';
                this.connections = [];
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.classList.add('connection-line');
                        line.setAttribute('data-from', i);
                        line.setAttribute('data-to', j);
                        gsap.set(line, { attr: { stroke: 'transparent', strokeWidth: 1 } });
                        this.connectionsSvg.appendChild(line);
                        this.connections.push(line);
                    }
                }
                this.updateConnectionPositions();
            }

            updateConnectionPositions() {
                this.connections.forEach(line => {
                    const fromIndex = parseInt(line.getAttribute('data-from'));
                    const toIndex = parseInt(line.getAttribute('data-to'));
                    const fromPos = this.nodePositions[fromIndex];
                    const toPos = this.nodePositions[toIndex];
                    gsap.set(line, {
                        attr: {
                            x1: fromPos.x,
                            y1: fromPos.y,
                            x2: toPos.x,
                            y2: toPos.y
                        }
                    });
                });
            }

            updateAllConnections() {
                this.nodes.forEach((node, index) => {
                    const x = gsap.getProperty(node, "x");
                    const y = gsap.getProperty(node, "y");
                    this.nodePositions[index] = { x: x + 14.5, y: y + 14.5 };
                });
                this.updateConnectionPositions();
            }

            updateConnections() {
                this.nodes.forEach((node, index) => {
                    const x = gsap.getProperty(node, "x");
                    const y = gsap.getProperty(node, "y");
                    this.nodePositions[index] = { x: x + 14.5, y: y + 14.5 };
                });
                this.updateConnectionPositions();
            }

            start() {
                this.init();
                this.masterTimeline.play();
            }

            buildMasterTimeline() {
                this.createIndividualPulsing(); // Start pulsing independently
                this.masterTimeline
                    .add(this.createConnectionActivation(), "+=3")
                    .add(this.createCoordinatedMovement(), "+=2")
                    .add(this.createSuperOrganismActivation(), "+=2");
            }

            createIndividualPulsing() {
                gsap.utils.toArray(this.nodes).forEach((node, i) => {
                    gsap.to(node, {
                        scale: 1.05 + Math.random() * 0.1,
                        duration: 1.25 + Math.random() * 0.55,
                        ease: "power2.inOut",
                        yoyo: true,
                        repeat: -1,
                        transformOrigin: "center center",
                        delay: gsap.utils.distribute({ base: 0, amount: 1, ease: "none" })(i)
                    });
                });
            }

            createConnectionActivation() {
                const shuffledConnections = [...this.connections].sort(() => Math.random() - 0.5);
                const tl = gsap.timeline();
                shuffledConnections.forEach(connection => {
                    tl.call(() => connection.classList.add('active'), [], "+=0.05");
                });
                return tl;
            }

            createCoordinatedMovement() {
                const tl = gsap.timeline();
                const staggerDelay = 0.1;
                const moveDuration = 2;
                const totalDuration = (this.nodes.length - 1) * staggerDelay + moveDuration;

                this.nodes.forEach((node, index) => {
                    tl.to(node, {
                        x: this.circleTargets[index].x,
                        y: this.circleTargets[index].y,
                        duration: moveDuration,
                        ease: "power2.inOut"
                    }, index * staggerDelay);
                });

                // Updates for connections - match the total animation duration
                tl.to({}, {
                    duration: totalDuration,
                    onUpdate: () => this.updateConnections()
                }, 0); // Start with first node

                // Ensure final positions are exact
                tl.call(() => {
                    // Update node positions to exact target positions
                    this.nodes.forEach((node, index) => {
                        this.nodePositions[index] = {
                            x: this.circleTargets[index].x + 14.5,
                            y: this.circleTargets[index].y + 14.5
                        };
                    });
                    this.updateConnectionPositions();
                }, [], totalDuration);

                return tl;
            }

            createSuperOrganismActivation() {
                const tl = gsap.timeline();

                // Kill individual pulsing animations
                tl.call(() => {
                    this.nodes.forEach(node => gsap.killTweensOf(node, "scale"));
                    gsap.to(this.nodes, { scale: 1, duration: 0.2 }); // Reset scale
                });

                const shuffledConnections = [...this.connections].sort(() => Math.random() - 0.5);
                const connectionDuration = shuffledConnections.length * 0.15;

                shuffledConnections.forEach((connection, index) => {
                    tl.call(() => {
                        connection.classList.remove('active');
                        connection.classList.add('super-organism');
                    }, [], index * 0.15);
                });

                // Synchronized pulsing - start after all connections are updated
                tl.to(this.nodes, {
                    scale: 1.15,
                    duration: 0.8,
                    ease: "power2.inOut",
                    yoyo: true,
                    repeat: -1,
                    transformOrigin: "center center"
                }, connectionDuration + 0.3); // Start after connection changes with small buffer

                return tl;
            }
        }
    </script>
</body>
</html>