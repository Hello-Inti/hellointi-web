<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Inti - Network Transformation Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Design System v1 Colors */
            --color-poppy: #E65C4F;
            --color-sunbeam: #F2B705;
            --color-peach: #F2A08D;
            --color-avocado: #A6A61B;
            --color-lavender: #D4C1EC;
            --color-eggshell: #F9F8F6;
            --color-beige: #E8E1D0;
            --color-charcoal: #403F3E;

            /* Typography */
            --font-display: 'Crimson Text', serif;
            --font-body: 'Inter', sans-serif;

            /* Transitions */
            --transition-fast: 0.15s ease-out;
            --transition-normal: 0.3s ease-out;
            --transition-slow: 0.5s ease-out;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: linear-gradient(135deg, var(--color-eggshell) 0%, #fff 100%);
            color: var(--color-charcoal);
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-container {
            max-width: 800px;
            width: 100%;
        }

        .demo-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .demo-header h1 {
            font-family: var(--font-display);
            font-size: 2rem;
            color: var(--color-charcoal);
            margin-bottom: 0.5rem;
        }

        .demo-header p {
            color: var(--color-charcoal);
            opacity: 0.7;
        }

        /* Hero Visual Container - matches landing page */
        .hero-visual {
            position: relative;
            height: 400px;
            width: 100%;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(64, 63, 62, 0.15);
            overflow: hidden;
        }

        .network-animation {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Connection lines SVG */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke: var(--color-avocado);
            stroke-width: 1;
            fill: none;
            opacity: 0;
            stroke-dasharray: 3, 3;
        }

        .connection-line.active {
            opacity: 0.3;
            animation: subtle-flow 4s ease-in-out infinite;
        }

        .connection-line.super-organism {
            opacity: 0.6;
            stroke-width: 2;
            stroke-dasharray: 3, 3; /* Keep dashed instead of solid */
            animation: energy-flow 3s ease-in-out infinite;
        }

        @keyframes subtle-flow {
            0%, 100% { stroke-dashoffset: 0; }
            50% { stroke-dashoffset: 6; }
        }

        @keyframes energy-flow {
            0%, 100% {
                stroke-dashoffset: 0;
                opacity: 0.6;
            }
            50% {
                stroke-dashoffset: -10;
                opacity: 0.8;
            }
        }

        /* Network nodes - no labels, random colors */
        .network-node {
            position: absolute;
            width: 29px;
            height: 29px;
            border-radius: 50%;
            cursor: pointer;
            transition: all var(--transition-normal);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(64, 63, 62, 0.2);
        }

        .network-node:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(64, 63, 62, 0.3);
        }

        /* Random color classes */
        .color-poppy { background: var(--color-poppy); }
        .color-sunbeam { background: var(--color-sunbeam); }
        .color-peach { background: var(--color-peach); }
        .color-avocado { background: var(--color-avocado); }
        .color-lavender { background: var(--color-lavender); }

        /* Individual random pulsing - now handled by GSAP */

        /* Synchronized pulsing for super organism state */
        .sync-pulse {
            animation: synchronized-pulse 2s ease-in-out infinite !important;
        }

        @keyframes synchronized-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(64, 63, 62, 0.2);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 4px 16px rgba(166, 166, 27, 0.4);
            }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .hero-visual {
                height: 300px;
            }

            .network-node {
                width: 24px;
                height: 24px;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <div class="demo-header">
            <h1>Network Transformation Animation</h1>
            <p>Prototype for Hero Section Integration</p>
        </div>

        <div class="hero-visual">
            <div class="network-animation">
                <!-- SVG for connection lines -->
                <svg class="connections-svg" id="connectionsSvg">
                    <!-- Connection lines will be dynamically generated -->
                </svg>

                <!-- Network nodes - 12 people with random colors and positions -->
                <div class="network-node color-poppy" id="node1"></div>
                <div class="network-node color-sunbeam" id="node2"></div>
                <div class="network-node color-peach" id="node3"></div>
                <div class="network-node color-avocado" id="node4"></div>
                <div class="network-node color-lavender" id="node5"></div>
                <div class="network-node color-poppy" id="node6"></div>
                <div class="network-node color-sunbeam" id="node7"></div>
                <div class="network-node color-peach" id="node8"></div>
                <div class="network-node color-avocado" id="node9"></div>
                <div class="network-node color-lavender" id="node10"></div>
                <div class="network-node color-poppy" id="node11"></div>
                <div class="network-node color-sunbeam" id="node12"></div>
            </div>
        </div>
    </div>

    <script>
        class NetworkTransformation {
            constructor() {
                this.nodes = [];
                this.connections = [];
                this.connectionsSvg = document.getElementById('connectionsSvg');
                this.isTransformed = false;

                this.init();
                this.startAnimation();
            }

            init() {
                // Get all node elements
                this.nodes = Array.from(document.querySelectorAll('.network-node'));

                // Position nodes randomly without overlap
                this.positionNodesRandomly();

                // Generate connection lines
                this.generateConnections();

                // Start individual pulsing animations immediately
                this.startIndividualPulsing();

                // Start the transformation after a delay (but connections appear 3 seconds after page load)
                setTimeout(() => {
                    this.startTransformation();
                }, 5000); // Increased to 5 seconds total (3 seconds for connections + 2 seconds buffer)
            }

            positionNodesRandomly() {
                const container = document.querySelector('.network-animation');
                const containerRect = container.getBoundingClientRect();
                const nodeSize = 29; // Updated for 20% larger nodes
                const margin = nodeSize + 10;
                const positions = [];

                this.nodes.forEach((node, index) => {
                    let x, y, attempts = 0;
                    let validPosition = false;

                    // Try to find a non-overlapping position
                    while (!validPosition && attempts < 50) {
                        x = margin + Math.random() * (containerRect.width - 2 * margin);
                        y = margin + Math.random() * (containerRect.height - 2 * margin);

                        // Check for overlaps with existing positions
                        validPosition = positions.every(pos => {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            return distance >= nodeSize * 2;
                        });

                        attempts++;
                    }

                    // If we couldn't find a non-overlapping position, use a grid fallback
                    if (!validPosition) {
                        const cols = 4;
                        const row = Math.floor(index / cols);
                        const col = index % cols;
                        x = (containerRect.width / cols) * col + (containerRect.width / cols) / 2;
                        y = (containerRect.height / 3) * row + (containerRect.height / 6);
                    }

                    positions.push({ x, y });
                    node.style.left = `${x - nodeSize/2}px`;
                    node.style.top = `${y - nodeSize/2}px`;
                });

                this.nodePositions = positions;
            }

            generateConnections() {
                // Clear existing connections
                this.connectionsSvg.innerHTML = '';
                this.connections = [];

                // Create connection lines between all nodes
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.classList.add('connection-line');
                        line.setAttribute('data-from', i);
                        line.setAttribute('data-to', j);
                        this.connectionsSvg.appendChild(line);
                        this.connections.push(line);
                    }
                }

                this.updateConnectionPositions();
            }

            updateConnectionPositions() {
                this.connections.forEach(line => {
                    const fromIndex = parseInt(line.getAttribute('data-from'));
                    const toIndex = parseInt(line.getAttribute('data-to'));

                    const fromPos = this.nodePositions[fromIndex];
                    const toPos = this.nodePositions[toIndex];

                    line.setAttribute('x1', fromPos.x);
                    line.setAttribute('y1', fromPos.y);
                    line.setAttribute('x2', toPos.x);
                    line.setAttribute('y2', toPos.y);
                });
            }

            startAnimation() {
                // Animation starts automatically on page load
                console.log('Network transformation animation started');
            }

            startIndividualPulsing() {
                // Create unique pulsing animations for each node with different timing and intensity
                this.nodes.forEach((node, index) => {
                    // Random duration between 1.25 and 1.8 seconds (2x faster)
                    const duration = 1.25 + Math.random() * 0.55;

                    // Random scale between 1.05 and 1.15
                    const scale = 1.05 + Math.random() * 0.1;

                    // Random delay to start out of sync (0 to 1 second, also faster)
                    const delay = Math.random() * 1;

                    // Create the pulsing animation
                    gsap.to(node, {
                        scale: scale,
                        duration: duration / 2,
                        ease: "power2.inOut",
                        delay: delay,
                        yoyo: true,
                        repeat: -1,
                        transformOrigin: "center center"
                    });
                });
            }

            startTransformation() {
                if (this.isTransformed) return;

                // Phase 1: Gradually activate connections (weeks 1-4) - starts 3 seconds after page load
                setTimeout(() => {
                    this.activateConnectionsGradually();
                }, 3000);

                // Phase 2: Move to coordinated positions (weeks 5-6)
                setTimeout(() => {
                    this.moveToCoordinatedPositions();
                }, 7000);

                // Phase 3: Synchronized super organism (week 7)
                setTimeout(() => {
                    this.activateSuperOrganism();
                }, 11000);
            }

            activateConnectionsGradually() {
                const shuffledConnections = [...this.connections].sort(() => Math.random() - 0.5);

                shuffledConnections.forEach((connection, index) => {
                    setTimeout(() => {
                        connection.classList.add('active');
                    }, index * 200); // Increased from 100ms to 200ms (50% slower)
                });
            }

            moveToCoordinatedPositions() {
                const container = document.querySelector('.network-animation');
                const containerRect = container.getBoundingClientRect();
                const centerX = containerRect.width / 2;
                const centerY = containerRect.height / 2;
                const radius = Math.min(containerRect.width, containerRect.height) * 0.35;

                // Create a timeline for coordinated movement with sticky connections
                const tl = gsap.timeline();

                this.nodes.forEach((node, index) => {
                    const angle = (index / this.nodes.length) * Math.PI * 2;
                    const targetX = centerX + Math.cos(angle) * radius;
                    const targetY = centerY + Math.sin(angle) * radius;

                    // Animate to new position with continuous connection updates
                    tl.to(node, {
                        left: `${targetX - 14.5}px`, // Half of 29px
                        top: `${targetY - 14.5}px`,  // Half of 29px
                        duration: 2,
                        ease: "power2.inOut",
                        onUpdate: () => {
                            // Update this node's position in our tracking array
                            const currentLeft = parseFloat(node.style.left) + 14.5;
                            const currentTop = parseFloat(node.style.top) + 14.5;
                            this.nodePositions[index] = { x: currentLeft, y: currentTop };

                            // Update all connection positions to keep them sticky
                            this.updateConnectionPositions();
                        },
                        onComplete: () => {
                            // Ensure final position is exactly where we want it
                            this.nodePositions[index] = { x: targetX, y: targetY };
                            this.updateConnectionPositions();
                        }
                    }, index * 0.1);
                });

                return tl;
            }

            activateSuperOrganism() {
                this.isTransformed = true;

                // Upgrade all connections to super organism state
                this.connections.forEach(connection => {
                    connection.classList.remove('active');
                    connection.classList.add('super-organism');
                });

                // Kill individual pulsing animations and start synchronized pulsing
                this.nodes.forEach(node => {
                    // Kill existing GSAP animations on this node
                    gsap.killTweensOf(node);

                    // Reset scale to 1
                    gsap.set(node, { scale: 1 });

                    // Start synchronized pulsing with GSAP (2x faster)
                    gsap.to(node, {
                        scale: 1.15,
                        duration: 0.5, // 2x faster
                        ease: "power2.inOut",
                        yoyo: true,
                        repeat: -1,
                        transformOrigin: "center center"
                    });
                });

                console.log('Super organism state activated');
            }
        }

        // Initialize the animation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new NetworkTransformation();
        });
    </script>
</body>
</html>